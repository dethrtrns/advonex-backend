# Advonex Backend Project Rules

This document outlines the key rules, conventions, and guidelines to follow during the development of the Advonex backend application. Adhering to these rules ensures consistency, maintainability, and quality across the codebase.

## 1. Technology Stack

- **Framework**: NestJS (`@nestjs/core` ^11.0.1)
- **Language**: TypeScript (^5.7.3)
- **ORM**: Prisma (`@prisma/client` ^6.5.0, `prisma` ^6.5.0)
- **Database**: PostgreSQL
- **API Documentation**: Swagger / OpenAPI (`@nestjs/swagger` ^11.0.7, `swagger-ui-express` ^5.0.1)
- **Authentication**: JWT (`@nestjs/jwt` ^11.0.0, `@nestjs/passport` ^11.0.5, `passport` ^0.7.0, `passport-jwt` ^4.0.1)
- **Validation**: `class-validator` (^0.14.1), `class-transformer` (^0.5.1)
- **Configuration**: `@nestjs/config` (^4.0.2)
- **File Uploads**: `multer` (1.4.5-lts.2), Cloudinary (`cloudinary` ^2.6.0) (if applicable, via abstraction)
- **Package Manager**: `pnpm`
- **Testing**: Jest (^29.7.0), Supertest (`supertest` ^7.0.0)
- **Linting**: ESLint (^9.18.0)
- **Formatting**: Prettier (^3.4.2)
- **Node.js Version**: >= 18 (as specified in `package.json`)

## 2. Architecture & Design Principles

- **Modular Design**: Follow NestJS modular architecture. Organize code into feature modules (e.g., `AuthModule`, `UsersModule`, `ProfilesModule`, `LawyersModule`, `ConsultationsModule`).
- **Separation of Concerns**: Maintain clear separation between Controllers (API layer), Services (business logic), and Modules. Use Repositories or Prisma Client directly within Services for data access.
- **Abstraction**: Use abstraction layers (e.g., dedicated services) when interacting with third-party APIs or services (like SMS providers for OTP).
- **DTOs**: Use Data Transfer Objects (DTOs) for request payloads and response bodies. Apply validation decorators (`class-validator`) to DTOs. Use `class-transformer` for data transformation.
  - **Prisma Type Integration**: Leverage Prisma-generated types (`@prisma/client`) within DTOs whenever possible to ensure consistency and reduce redundancy. Avoid creating DTOs that merely duplicate existing Prisma model structures without adding value (like validation or transformation). Use `PartialType`, `OmitType`, `PickType` from `@nestjs/swagger` (or `@nestjs/mapped-types`) to build upon Prisma types for specific use cases (e.g., update DTOs).
- **Abstraction**: Use abstraction layers (e.g., dedicated services) when interacting with third-party APIs or services (like SMS providers for OTP, Cloudinary for file storage).
- **Configuration Management**: Use the `@nestjs/config` module to manage environment variables loaded from `.env` files. Never commit `.env` files.
- **Error Handling**: Implement consistent error handling. Use NestJS built-in exceptions or custom exceptions where appropriate. Provide meaningful error responses to the client.
- **Logging**: Implement comprehensive logging throughout the application for debugging and monitoring purposes. Use the built-in `Logger` or a dedicated logging library.

## 3. Database & Prisma

- **Schema Definition**: The single source of truth for the database schema is `prisma/schema.prisma`.
- **Prisma Types**: The types generated by `npx prisma generate` (located in `node_modules/.prisma/client`) are the single source of truth for database entity structures within the application code. Prefer using these types directly in services and repositories.
- **Migrations**: Use `prisma migrate dev` for development and `prisma migrate deploy` for production environments to manage schema changes.
- **Prisma Client**: Use Prisma Client for all database interactions. Inject `PrismaService` into services that require database access.
- **Data Seeding**: Use `prisma db seed` (configured via `package.json` and `prisma/seed.ts`) to populate initial data (e.g., `PracticeArea`, `PracticeCourt`, predefined `Service`).
- **Relation Management**:
  - Handle profile creation (`ClientProfile`/`LawyerProfile`) automatically upon user registration based on the selected `role`. Link profiles back to the `User`.
  - When updating lawyer profiles, ensure consistency for `specializationId` and `primaryCourtId` by validating against the lawyer's linked `LawyerPracticeArea` and `LawyerPracticeCourt` records respectively.
  - Use Prisma's `connect`, `disconnect`, or `set` operations for managing many-to-many relationships (e.g., `LawyerPracticeArea`, `LawyerPracticeCourt`, `LawyerService`).
- **OTP Cleanup**: Implement a mechanism (e.g., a scheduled task using `@nestjs/schedule`) to periodically delete expired `Otp` records.

## 4. API Development

- **RESTful Principles**: Design API endpoints following REST conventions.
- **Swagger Documentation**: Annotate all controllers, methods, DTOs, and responses using `@nestjs/swagger` decorators to generate comprehensive OpenAPI documentation. Access it via `/api`.
- **Input Validation**: Apply validation pipes globally or per-endpoint using DTOs decorated with `class-validator`.
- **Authentication & Authorization**:
  - Use JWT-based authentication. Protect routes using appropriate guards (e.g., `JwtAuthGuard`).
  - Implement Role-Based Access Control (RBAC) using guards based on the `User.role` enum (`CLIENT`, `LAWYER`, `ADMIN`). Ensure users can only access or modify resources they are permitted to.
- **Pagination**: Implement pagination (`skip`, `take` or page/limit) for API endpoints returning lists of resources (e.g., `GET /lawyers/search`).
- **Response Structure**: Define consistent response structures, potentially using interceptors.

## 5. Coding Standards & Quality

- **Linting & Formatting**: Adhere strictly to the ESLint and Prettier rules defined in the project configuration. Run `pnpm run format` and `pnpm run lint --fix` before committing code.
- **Code Style**: Write clean, readable, reusable, and maintainable TypeScript code. Follow standard naming conventions.
- **Comments**: Add JSDoc/TSDoc comments to functions, classes, and complex logic sections to explain their purpose, parameters, and return values.
- **Testing**: Write unit tests (using Jest) for services and controllers. Aim for high test coverage. Implement integration tests (`*.e2e-spec.ts`) for critical user flows.
- **Type Safety**: Leverage TypeScript's type system. Avoid using `any` where possible. Define clear interfaces and types.

## 6. Workflow & Environment

- **Version Control**: Use Git. Follow a consistent branching strategy (e.g., Gitflow or GitHub Flow). Use meaningful commit messages. Create Pull Requests for code reviews.
- **Dependency Management**: Use `pnpm` for installing and managing dependencies. Keep dependencies up-to-date.
- **Environment**: The primary development environment is Windows 10/11.
- **Terminal**: Use PowerShell as the default terminal. For bash commands (like those in `README.md`), use Git Bash.
- **`.gitignore`**: Ensure generated files, environment files (`.env*`), logs, and IDE configurations are correctly ignored as per `.gitignore`.
